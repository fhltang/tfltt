// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TflAPIPresentationEntitiesRoadDisruption tfl Api presentation entities road disruption
//
// swagger:model Tfl.Api.Presentation.Entities.RoadDisruption
type TflAPIPresentationEntitiesRoadDisruption struct {

	// Describes the nature of disruption e.g. Traffic Incidents, Works
	Category string `json:"category,omitempty"`

	// Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate.
	Comments string `json:"comments,omitempty"`

	// The Ids of affected corridors, if any.
	CorridorIds []string `json:"corridorIds"`

	// Text of the most recent update from the LSTCC on the state of the
	//              disruption, including the current traffic impact and any advice to
	//              road users.
	CurrentUpdate string `json:"currentUpdate,omitempty"`

	// The time when the last CurrentUpdate description was recorded,
	//             or null if no CurrentUpdate has been applied.
	// Format: date-time
	CurrentUpdateDateTime strfmt.DateTime `json:"currentUpdateDateTime,omitempty"`

	// The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned
	//             disruptions in progress, this field will be omitted.
	// Format: date-time
	EndDateTime strfmt.DateTime `json:"endDateTime,omitempty"`

	// Geography version of Point for output as GeoJSON.
	//             Can not use Geometry in a consistent way as non-TIMS disruptions do not have a polygon
	Geography *SystemDataSpatialDbGeography `json:"geography,omitempty"`

	// GeoJSON formatted latitude/longitude (WGS84) pairs forming an enclosed polyline or polygon. The polygon will only be included where affected streets information
	//             is not available for the disruption, would be inappropriate (e.g. a very large number of streets), or is centred on an area without streets (e.g. a football stadium).
	Geometry *SystemDataSpatialDbGeography `json:"geometry,omitempty"`

	// True if any of the affected Streets have a "Full Closure" status, false otherwise. A RoadDisruption that has HasClosures is considered a
	//             Severe or Serious disruption for severity filtering purposes.
	HasClosures bool `json:"hasClosures,omitempty"`

	// Unique identifier for the road disruption
	ID string `json:"id,omitempty"`

	// True if the disruption is planned on a future date that is open to change
	IsProvisional bool `json:"isProvisional,omitempty"`

	// The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly
	//             compare two instances of the same disruption to determine if it has been changed.
	// Format: date-time
	LastModifiedTime strfmt.DateTime `json:"lastModifiedTime,omitempty"`

	// This describes the level of potential impact on traffic operations of the disruption.
	//             High = e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention
	//             Medium = This is the default value
	//             Low = e.g. a frequently occurring disruption which is well known
	LevelOfInterest string `json:"levelOfInterest,omitempty"`

	// The text of any associated link
	LinkText string `json:"linkText,omitempty"`

	// The url of any associated link
	LinkURL string `json:"linkUrl,omitempty"`

	// Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited.
	Location string `json:"location,omitempty"`

	// An ordinal of the disruption based on severity, level of interest and corridor.
	Ordinal int32 `json:"ordinal,omitempty"`

	// Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string.
	Point string `json:"point,omitempty"`

	// publish end date
	// Format: date-time
	PublishEndDate strfmt.DateTime `json:"publishEndDate,omitempty"`

	// TDM Additional properties
	// Format: date-time
	PublishStartDate strfmt.DateTime `json:"publishStartDate,omitempty"`

	// recurring schedules
	RecurringSchedules []*TflAPIPresentationEntitiesRoadDisruptionSchedule `json:"recurringSchedules"`

	// road disruption impact areas
	RoadDisruptionImpactAreas []*TflAPIPresentationEntitiesRoadDisruptionImpactArea `json:"roadDisruptionImpactAreas"`

	// road disruption lines
	RoadDisruptionLines []*TflAPIPresentationEntitiesRoadDisruptionLine `json:"roadDisruptionLines"`

	// Any associated road project
	RoadProject *TflAPIPresentationEntitiesRoadProject `json:"roadProject,omitempty"`

	// A description of the severity of the disruption.
	Severity string `json:"severity,omitempty"`

	// The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.
	//             For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator.
	// Format: date-time
	StartDateTime strfmt.DateTime `json:"startDateTime,omitempty"`

	// This describes the status of the disruption.
	//             Active = currently in progress
	//             Active Long Term = currently in progress and long term
	//             Scheduled = scheduled to start within the next 180 days
	//             Recurring Works = planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.
	//             Recently Cleared = recently cleared in the last 24 hours
	//             Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end.
	Status string `json:"status,omitempty"`

	// A collection of zero or more streets affected by the disruption.
	Streets []*TflAPIPresentationEntitiesStreet `json:"streets"`

	// Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load
	SubCategory string `json:"subCategory,omitempty"`

	// time frame
	TimeFrame string `json:"timeFrame,omitempty"`

	// URL to retrieve this road disruption
	URL string `json:"url,omitempty"`
}

// Validate validates this tfl Api presentation entities road disruption
func (m *TflAPIPresentationEntitiesRoadDisruption) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCurrentUpdateDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeography(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeometry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModifiedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublishStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringSchedules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoadDisruptionImpactAreas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoadDisruptionLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoadProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreets(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateCurrentUpdateDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentUpdateDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("currentUpdateDateTime", "body", "date-time", m.CurrentUpdateDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateEndDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("endDateTime", "body", "date-time", m.EndDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateGeography(formats strfmt.Registry) error {
	if swag.IsZero(m.Geography) { // not required
		return nil
	}

	if m.Geography != nil {
		if err := m.Geography.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("geography")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("geography")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateGeometry(formats strfmt.Registry) error {
	if swag.IsZero(m.Geometry) { // not required
		return nil
	}

	if m.Geometry != nil {
		if err := m.Geometry.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("geometry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("geometry")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateLastModifiedTime(formats strfmt.Registry) error {
	if swag.IsZero(m.LastModifiedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("lastModifiedTime", "body", "date-time", m.LastModifiedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validatePublishEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.PublishEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("publishEndDate", "body", "date-time", m.PublishEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validatePublishStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.PublishStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("publishStartDate", "body", "date-time", m.PublishStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateRecurringSchedules(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringSchedules) { // not required
		return nil
	}

	for i := 0; i < len(m.RecurringSchedules); i++ {
		if swag.IsZero(m.RecurringSchedules[i]) { // not required
			continue
		}

		if m.RecurringSchedules[i] != nil {
			if err := m.RecurringSchedules[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("recurringSchedules" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("recurringSchedules" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateRoadDisruptionImpactAreas(formats strfmt.Registry) error {
	if swag.IsZero(m.RoadDisruptionImpactAreas) { // not required
		return nil
	}

	for i := 0; i < len(m.RoadDisruptionImpactAreas); i++ {
		if swag.IsZero(m.RoadDisruptionImpactAreas[i]) { // not required
			continue
		}

		if m.RoadDisruptionImpactAreas[i] != nil {
			if err := m.RoadDisruptionImpactAreas[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("roadDisruptionImpactAreas" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("roadDisruptionImpactAreas" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateRoadDisruptionLines(formats strfmt.Registry) error {
	if swag.IsZero(m.RoadDisruptionLines) { // not required
		return nil
	}

	for i := 0; i < len(m.RoadDisruptionLines); i++ {
		if swag.IsZero(m.RoadDisruptionLines[i]) { // not required
			continue
		}

		if m.RoadDisruptionLines[i] != nil {
			if err := m.RoadDisruptionLines[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("roadDisruptionLines" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("roadDisruptionLines" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateRoadProject(formats strfmt.Registry) error {
	if swag.IsZero(m.RoadProject) { // not required
		return nil
	}

	if m.RoadProject != nil {
		if err := m.RoadProject.Validate(formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("roadProject")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("roadProject")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateStartDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("startDateTime", "body", "date-time", m.StartDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) validateStreets(formats strfmt.Registry) error {
	if swag.IsZero(m.Streets) { // not required
		return nil
	}

	for i := 0; i < len(m.Streets); i++ {
		if swag.IsZero(m.Streets[i]) { // not required
			continue
		}

		if m.Streets[i] != nil {
			if err := m.Streets[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("streets" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("streets" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this tfl Api presentation entities road disruption based on the context it is used
func (m *TflAPIPresentationEntitiesRoadDisruption) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGeography(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeometry(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecurringSchedules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoadDisruptionImpactAreas(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoadDisruptionLines(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRoadProject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStreets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateGeography(ctx context.Context, formats strfmt.Registry) error {

	if m.Geography != nil {

		if swag.IsZero(m.Geography) { // not required
			return nil
		}

		if err := m.Geography.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("geography")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("geography")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateGeometry(ctx context.Context, formats strfmt.Registry) error {

	if m.Geometry != nil {

		if swag.IsZero(m.Geometry) { // not required
			return nil
		}

		if err := m.Geometry.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("geometry")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("geometry")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateRecurringSchedules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RecurringSchedules); i++ {

		if m.RecurringSchedules[i] != nil {

			if swag.IsZero(m.RecurringSchedules[i]) { // not required
				return nil
			}

			if err := m.RecurringSchedules[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("recurringSchedules" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("recurringSchedules" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateRoadDisruptionImpactAreas(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RoadDisruptionImpactAreas); i++ {

		if m.RoadDisruptionImpactAreas[i] != nil {

			if swag.IsZero(m.RoadDisruptionImpactAreas[i]) { // not required
				return nil
			}

			if err := m.RoadDisruptionImpactAreas[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("roadDisruptionImpactAreas" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("roadDisruptionImpactAreas" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateRoadDisruptionLines(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RoadDisruptionLines); i++ {

		if m.RoadDisruptionLines[i] != nil {

			if swag.IsZero(m.RoadDisruptionLines[i]) { // not required
				return nil
			}

			if err := m.RoadDisruptionLines[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("roadDisruptionLines" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("roadDisruptionLines" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateRoadProject(ctx context.Context, formats strfmt.Registry) error {

	if m.RoadProject != nil {

		if swag.IsZero(m.RoadProject) { // not required
			return nil
		}

		if err := m.RoadProject.ContextValidate(ctx, formats); err != nil {
			ve := new(errors.Validation)
			if stderrors.As(err, &ve) {
				return ve.ValidateName("roadProject")
			}
			ce := new(errors.CompositeError)
			if stderrors.As(err, &ce) {
				return ce.ValidateName("roadProject")
			}

			return err
		}
	}

	return nil
}

func (m *TflAPIPresentationEntitiesRoadDisruption) contextValidateStreets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Streets); i++ {

		if m.Streets[i] != nil {

			if swag.IsZero(m.Streets[i]) { // not required
				return nil
			}

			if err := m.Streets[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("streets" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("streets" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TflAPIPresentationEntitiesRoadDisruption) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TflAPIPresentationEntitiesRoadDisruption) UnmarshalBinary(b []byte) error {
	var res TflAPIPresentationEntitiesRoadDisruption
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
