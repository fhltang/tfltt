// Code generated by go-swagger; DO NOT EDIT.

package stop_point

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new stop point API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new stop point API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new stop point API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for stop point API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationXML sets the Accept header to "application/xml".
func WithAcceptApplicationXML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/xml"}
}

// WithAcceptTextJSON sets the Accept header to "text/json".
func WithAcceptTextJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/json"}
}

// WithAcceptTextXML sets the Accept header to "text/xml".
func WithAcceptTextXML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/xml"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	StopPointArrivalDepartures(params *StopPointArrivalDeparturesParams, opts ...ClientOption) (*StopPointArrivalDeparturesOK, error)

	StopPointArrivals(params *StopPointArrivalsParams, opts ...ClientOption) (*StopPointArrivalsOK, error)

	StopPointCrowding(params *StopPointCrowdingParams, opts ...ClientOption) (*StopPointCrowdingOK, error)

	StopPointDirection(params *StopPointDirectionParams, opts ...ClientOption) (*StopPointDirectionOK, error)

	StopPointDisruption(params *StopPointDisruptionParams, opts ...ClientOption) (*StopPointDisruptionOK, error)

	StopPointDisruptionByMode(params *StopPointDisruptionByModeParams, opts ...ClientOption) (*StopPointDisruptionByModeOK, error)

	StopPointGet(params *StopPointGetParams, opts ...ClientOption) (*StopPointGetOK, error)

	StopPointGetByGeoPoint(params *StopPointGetByGeoPointParams, opts ...ClientOption) (*StopPointGetByGeoPointOK, error)

	StopPointGetByMode(params *StopPointGetByModeParams, opts ...ClientOption) (*StopPointGetByModeOK, error)

	StopPointGetBySms(params *StopPointGetBySmsParams, opts ...ClientOption) (*StopPointGetBySmsOK, error)

	StopPointGetByType(params *StopPointGetByTypeParams, opts ...ClientOption) (*StopPointGetByTypeOK, error)

	StopPointGetByTypeWithPagination(params *StopPointGetByTypeWithPaginationParams, opts ...ClientOption) (*StopPointGetByTypeWithPaginationOK, error)

	StopPointGetCarParksByID(params *StopPointGetCarParksByIDParams, opts ...ClientOption) (*StopPointGetCarParksByIDOK, error)

	StopPointGetServiceTypes(params *StopPointGetServiceTypesParams, opts ...ClientOption) (*StopPointGetServiceTypesOK, error)

	StopPointGetTaxiRanksByIds(params *StopPointGetTaxiRanksByIdsParams, opts ...ClientOption) (*StopPointGetTaxiRanksByIdsOK, error)

	StopPointMetaCategories(params *StopPointMetaCategoriesParams, opts ...ClientOption) (*StopPointMetaCategoriesOK, error)

	StopPointMetaModes(params *StopPointMetaModesParams, opts ...ClientOption) (*StopPointMetaModesOK, error)

	StopPointMetaStopTypes(params *StopPointMetaStopTypesParams, opts ...ClientOption) (*StopPointMetaStopTypesOK, error)

	StopPointReachableFrom(params *StopPointReachableFromParams, opts ...ClientOption) (*StopPointReachableFromOK, error)

	StopPointRoute(params *StopPointRouteParams, opts ...ClientOption) (*StopPointRouteOK, error)

	StopPointSearch(params *StopPointSearchParams, opts ...ClientOption) (*StopPointSearchOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
StopPointArrivalDepartures gets the list of arrival and departure predictions for the given stop point id overground elizabeth line and thameslink only
*/
func (a *Client) StopPointArrivalDepartures(params *StopPointArrivalDeparturesParams, opts ...ClientOption) (*StopPointArrivalDeparturesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointArrivalDeparturesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_ArrivalDepartures",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/ArrivalDepartures",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointArrivalDeparturesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointArrivalDeparturesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_ArrivalDepartures: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointArrivals gets the list of arrival predictions for the given stop point id
*/
func (a *Client) StopPointArrivals(params *StopPointArrivalsParams, opts ...ClientOption) (*StopPointArrivalsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointArrivalsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Arrivals",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/Arrivals",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointArrivalsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointArrivalsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Arrivals: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointCrowding gets all the crowding data static for the stop point Id plus crowding data for a given line and optionally a particular direction
*/
func (a *Client) StopPointCrowding(params *StopPointCrowdingParams, opts ...ClientOption) (*StopPointCrowdingOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointCrowdingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Crowding",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/Crowding/{line}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointCrowdingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointCrowdingOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Crowding: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointDirection returns the canonical direction inbound or outbound for a given pair of stop point ids in the direction from and gt to
*/
func (a *Client) StopPointDirection(params *StopPointDirectionParams, opts ...ClientOption) (*StopPointDirectionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointDirectionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Direction",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/DirectionTo/{toStopPointId}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointDirectionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointDirectionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Direction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointDisruption gets all disruptions for the specified stop point Id plus disruptions for any child naptan records it may have
*/
func (a *Client) StopPointDisruption(params *StopPointDisruptionParams, opts ...ClientOption) (*StopPointDisruptionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointDisruptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Disruption",
		Method:             "GET",
		PathPattern:        "/StopPoint/{ids}/Disruption",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointDisruptionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointDisruptionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Disruption: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointDisruptionByMode gets a distinct list of disrupted stop points for the given modes
*/
func (a *Client) StopPointDisruptionByMode(params *StopPointDisruptionByModeParams, opts ...ClientOption) (*StopPointDisruptionByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointDisruptionByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_DisruptionByMode",
		Method:             "GET",
		PathPattern:        "/StopPoint/Mode/{modes}/Disruption",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointDisruptionByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointDisruptionByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_DisruptionByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGet gets a list of stop points corresponding to the given list of stop ids
*/
func (a *Client) StopPointGet(params *StopPointGetParams, opts ...ClientOption) (*StopPointGetOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Get",
		Method:             "GET",
		PathPattern:        "/StopPoint/{ids}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetByGeoPoint gets a list of stop points within radius by the specified criteria
*/
func (a *Client) StopPointGetByGeoPoint(params *StopPointGetByGeoPointParams, opts ...ClientOption) (*StopPointGetByGeoPointOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetByGeoPointParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetByGeoPoint",
		Method:             "GET",
		PathPattern:        "/StopPoint",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetByGeoPointReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetByGeoPointOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetByGeoPoint: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetByMode gets a list of stop points filtered by the modes available at that stop point
*/
func (a *Client) StopPointGetByMode(params *StopPointGetByModeParams, opts ...ClientOption) (*StopPointGetByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetByMode",
		Method:             "GET",
		PathPattern:        "/StopPoint/Mode/{modes}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetBySms gets a stop point for a given sms code
*/
func (a *Client) StopPointGetBySms(params *StopPointGetBySmsParams, opts ...ClientOption) (*StopPointGetBySmsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetBySmsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetBySms",
		Method:             "GET",
		PathPattern:        "/StopPoint/Sms/{id}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetBySmsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetBySmsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetBySms: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetByType gets all stop points of a given type
*/
func (a *Client) StopPointGetByType(params *StopPointGetByTypeParams, opts ...ClientOption) (*StopPointGetByTypeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetByTypeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetByType",
		Method:             "GET",
		PathPattern:        "/StopPoint/Type/{types}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetByTypeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetByTypeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetByType: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetByTypeWithPagination gets all the stop points of given type s with a page number
*/
func (a *Client) StopPointGetByTypeWithPagination(params *StopPointGetByTypeWithPaginationParams, opts ...ClientOption) (*StopPointGetByTypeWithPaginationOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetByTypeWithPaginationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetByTypeWithPagination",
		Method:             "GET",
		PathPattern:        "/StopPoint/Type/{types}/page/{page}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetByTypeWithPaginationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetByTypeWithPaginationOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetByTypeWithPagination: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetCarParksByID gets car parks corresponding to the given stop point id
*/
func (a *Client) StopPointGetCarParksByID(params *StopPointGetCarParksByIDParams, opts ...ClientOption) (*StopPointGetCarParksByIDOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetCarParksByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetCarParksById",
		Method:             "GET",
		PathPattern:        "/StopPoint/{stopPointId}/CarParks",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetCarParksByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetCarParksByIDOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetCarParksById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetServiceTypes gets the service types for a given stoppoint
*/
func (a *Client) StopPointGetServiceTypes(params *StopPointGetServiceTypesParams, opts ...ClientOption) (*StopPointGetServiceTypesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetServiceTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetServiceTypes",
		Method:             "GET",
		PathPattern:        "/StopPoint/ServiceTypes",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetServiceTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetServiceTypesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetServiceTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointGetTaxiRanksByIds gets a list of taxi ranks corresponding to the given stop point id
*/
func (a *Client) StopPointGetTaxiRanksByIds(params *StopPointGetTaxiRanksByIdsParams, opts ...ClientOption) (*StopPointGetTaxiRanksByIdsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointGetTaxiRanksByIdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_GetTaxiRanksByIds",
		Method:             "GET",
		PathPattern:        "/StopPoint/{stopPointId}/TaxiRanks",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointGetTaxiRanksByIdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointGetTaxiRanksByIdsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_GetTaxiRanksByIds: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointMetaCategories gets the list of available stop point additional information categories
*/
func (a *Client) StopPointMetaCategories(params *StopPointMetaCategoriesParams, opts ...ClientOption) (*StopPointMetaCategoriesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointMetaCategoriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_MetaCategories",
		Method:             "GET",
		PathPattern:        "/StopPoint/Meta/Categories",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointMetaCategoriesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointMetaCategoriesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_MetaCategories: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointMetaModes gets the list of available stop point modes
*/
func (a *Client) StopPointMetaModes(params *StopPointMetaModesParams, opts ...ClientOption) (*StopPointMetaModesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointMetaModesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_MetaModes",
		Method:             "GET",
		PathPattern:        "/StopPoint/Meta/Modes",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointMetaModesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointMetaModesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_MetaModes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointMetaStopTypes gets the list of available stop point types
*/
func (a *Client) StopPointMetaStopTypes(params *StopPointMetaStopTypesParams, opts ...ClientOption) (*StopPointMetaStopTypesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointMetaStopTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_MetaStopTypes",
		Method:             "GET",
		PathPattern:        "/StopPoint/Meta/StopTypes",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointMetaStopTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointMetaStopTypesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_MetaStopTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointReachableFrom gets stopoints that are reachable from a station line combination
*/
func (a *Client) StopPointReachableFrom(params *StopPointReachableFromParams, opts ...ClientOption) (*StopPointReachableFromOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointReachableFromParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_ReachableFrom",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/CanReachOnLine/{lineId}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointReachableFromReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointReachableFromOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_ReachableFrom: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointRoute returns the route sections for all the lines that service the given stop point ids
*/
func (a *Client) StopPointRoute(params *StopPointRouteParams, opts ...ClientOption) (*StopPointRouteOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointRouteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Route",
		Method:             "GET",
		PathPattern:        "/StopPoint/{id}/Route",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointRouteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointRouteOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Route: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPointSearch searches stop points by their common name or their 5 digit countdown bus stop code
*/
func (a *Client) StopPointSearch(params *StopPointSearchParams, opts ...ClientOption) (*StopPointSearchOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPointSearchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopPoint_Search",
		Method:             "GET",
		PathPattern:        "/StopPoint/Search/{query}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &StopPointSearchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPointSearchOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopPoint_Search: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
