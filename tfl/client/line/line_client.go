// Code generated by go-swagger; DO NOT EDIT.

package line

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new line API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new line API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new line API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for line API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationXML sets the Accept header to "application/xml".
func WithAcceptApplicationXML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/xml"}
}

// WithAcceptTextJSON sets the Accept header to "text/json".
func WithAcceptTextJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/json"}
}

// WithAcceptTextXML sets the Accept header to "text/xml".
func WithAcceptTextXML(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/xml"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	LineArrivals(params *LineArrivalsParams, opts ...ClientOption) (*LineArrivalsOK, error)

	LineDisruption(params *LineDisruptionParams, opts ...ClientOption) (*LineDisruptionOK, error)

	LineDisruptionByMode(params *LineDisruptionByModeParams, opts ...ClientOption) (*LineDisruptionByModeOK, error)

	LineGet(params *LineGetParams, opts ...ClientOption) (*LineGetOK, error)

	LineGetByMode(params *LineGetByModeParams, opts ...ClientOption) (*LineGetByModeOK, error)

	LineLineRoutesByIds(params *LineLineRoutesByIdsParams, opts ...ClientOption) (*LineLineRoutesByIdsOK, error)

	LineMetaDisruptionCategories(params *LineMetaDisruptionCategoriesParams, opts ...ClientOption) (*LineMetaDisruptionCategoriesOK, error)

	LineMetaModes(params *LineMetaModesParams, opts ...ClientOption) (*LineMetaModesOK, error)

	LineMetaServiceTypes(params *LineMetaServiceTypesParams, opts ...ClientOption) (*LineMetaServiceTypesOK, error)

	LineMetaSeverity(params *LineMetaSeverityParams, opts ...ClientOption) (*LineMetaSeverityOK, error)

	LineRoute(params *LineRouteParams, opts ...ClientOption) (*LineRouteOK, error)

	LineRouteByMode(params *LineRouteByModeParams, opts ...ClientOption) (*LineRouteByModeOK, error)

	LineRouteSequence(params *LineRouteSequenceParams, opts ...ClientOption) (*LineRouteSequenceOK, error)

	LineSearch(params *LineSearchParams, opts ...ClientOption) (*LineSearchOK, error)

	LineStatus(params *LineStatusParams, opts ...ClientOption) (*LineStatusOK, error)

	LineStatusByIds(params *LineStatusByIdsParams, opts ...ClientOption) (*LineStatusByIdsOK, error)

	LineStatusByMode(params *LineStatusByModeParams, opts ...ClientOption) (*LineStatusByModeOK, error)

	LineStatusBySeverity(params *LineStatusBySeverityParams, opts ...ClientOption) (*LineStatusBySeverityOK, error)

	LineStopPoints(params *LineStopPointsParams, opts ...ClientOption) (*LineStopPointsOK, error)

	LineTimetable(params *LineTimetableParams, opts ...ClientOption) (*LineTimetableOK, error)

	LineTimetableTo(params *LineTimetableToParams, opts ...ClientOption) (*LineTimetableToOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
LineArrivals gets the list of arrival predictions for given line ids based at the given stop
*/
func (a *Client) LineArrivals(params *LineArrivalsParams, opts ...ClientOption) (*LineArrivalsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineArrivalsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Arrivals",
		Method:             "GET",
		PathPattern:        "/Line/{ids}/Arrivals/{stopPointId}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineArrivalsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineArrivalsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Arrivals: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineDisruption gets disruptions for the given line ids
*/
func (a *Client) LineDisruption(params *LineDisruptionParams, opts ...ClientOption) (*LineDisruptionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineDisruptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Disruption",
		Method:             "GET",
		PathPattern:        "/Line/{ids}/Disruption",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineDisruptionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineDisruptionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Disruption: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineDisruptionByMode gets disruptions for all lines of the given modes
*/
func (a *Client) LineDisruptionByMode(params *LineDisruptionByModeParams, opts ...ClientOption) (*LineDisruptionByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineDisruptionByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_DisruptionByMode",
		Method:             "GET",
		PathPattern:        "/Line/Mode/{modes}/Disruption",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineDisruptionByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineDisruptionByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_DisruptionByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineGet gets lines that match the specified line ids
*/
func (a *Client) LineGet(params *LineGetParams, opts ...ClientOption) (*LineGetOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Get",
		Method:             "GET",
		PathPattern:        "/Line/{ids}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineGetOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Get: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineGetByMode gets lines that serve the given modes
*/
func (a *Client) LineGetByMode(params *LineGetByModeParams, opts ...ClientOption) (*LineGetByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineGetByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_GetByMode",
		Method:             "GET",
		PathPattern:        "/Line/Mode/{modes}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineGetByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineGetByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_GetByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineLineRoutesByIds gets all valid routes for given line ids including the name and id of the originating and terminating stops for each route
*/
func (a *Client) LineLineRoutesByIds(params *LineLineRoutesByIdsParams, opts ...ClientOption) (*LineLineRoutesByIdsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineLineRoutesByIdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_LineRoutesByIds",
		Method:             "GET",
		PathPattern:        "/Line/{ids}/Route",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineLineRoutesByIdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineLineRoutesByIdsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_LineRoutesByIds: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineMetaDisruptionCategories gets a list of valid disruption categories
*/
func (a *Client) LineMetaDisruptionCategories(params *LineMetaDisruptionCategoriesParams, opts ...ClientOption) (*LineMetaDisruptionCategoriesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineMetaDisruptionCategoriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_MetaDisruptionCategories",
		Method:             "GET",
		PathPattern:        "/Line/Meta/DisruptionCategories",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineMetaDisruptionCategoriesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineMetaDisruptionCategoriesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_MetaDisruptionCategories: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineMetaModes gets a list of valid modes
*/
func (a *Client) LineMetaModes(params *LineMetaModesParams, opts ...ClientOption) (*LineMetaModesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineMetaModesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_MetaModes",
		Method:             "GET",
		PathPattern:        "/Line/Meta/Modes",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineMetaModesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineMetaModesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_MetaModes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineMetaServiceTypes gets a list of valid service types to filter on
*/
func (a *Client) LineMetaServiceTypes(params *LineMetaServiceTypesParams, opts ...ClientOption) (*LineMetaServiceTypesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineMetaServiceTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_MetaServiceTypes",
		Method:             "GET",
		PathPattern:        "/Line/Meta/ServiceTypes",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineMetaServiceTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineMetaServiceTypesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_MetaServiceTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineMetaSeverity gets a list of valid severity codes
*/
func (a *Client) LineMetaSeverity(params *LineMetaSeverityParams, opts ...ClientOption) (*LineMetaSeverityOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineMetaSeverityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_MetaSeverity",
		Method:             "GET",
		PathPattern:        "/Line/Meta/Severity",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineMetaSeverityReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineMetaSeverityOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_MetaSeverity: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineRoute gets all valid routes for all lines including the name and id of the originating and terminating stops for each route
*/
func (a *Client) LineRoute(params *LineRouteParams, opts ...ClientOption) (*LineRouteOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineRouteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Route",
		Method:             "GET",
		PathPattern:        "/Line/Route",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineRouteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineRouteOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Route: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineRouteByMode gets all lines and their valid routes for given modes including the name and id of the originating and terminating stops for each route
*/
func (a *Client) LineRouteByMode(params *LineRouteByModeParams, opts ...ClientOption) (*LineRouteByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineRouteByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_RouteByMode",
		Method:             "GET",
		PathPattern:        "/Line/Mode/{modes}/Route",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineRouteByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineRouteByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_RouteByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineRouteSequence gets all valid routes for given line id including the sequence of stops on each route
*/
func (a *Client) LineRouteSequence(params *LineRouteSequenceParams, opts ...ClientOption) (*LineRouteSequenceOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineRouteSequenceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_RouteSequence",
		Method:             "GET",
		PathPattern:        "/Line/{id}/Route/Sequence/{direction}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineRouteSequenceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineRouteSequenceOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_RouteSequence: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineSearch searches for lines or routes matching the query string
*/
func (a *Client) LineSearch(params *LineSearchParams, opts ...ClientOption) (*LineSearchOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineSearchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Search",
		Method:             "GET",
		PathPattern:        "/Line/Search/{query}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineSearchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineSearchOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Search: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineStatus gets the line status for given line ids during the provided dates e g minor delays
*/
func (a *Client) LineStatus(params *LineStatusParams, opts ...ClientOption) (*LineStatusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Status",
		Method:             "GET",
		PathPattern:        "/Line/{ids}/Status/{StartDate}/to/{EndDate}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineStatusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Status: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineStatusByIds gets the line status of for given line ids e g minor delays
*/
func (a *Client) LineStatusByIds(params *LineStatusByIdsParams, opts ...ClientOption) (*LineStatusByIdsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineStatusByIdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_StatusByIds",
		Method:             "GET",
		PathPattern:        "/Line/{ids}/Status",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineStatusByIdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineStatusByIdsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_StatusByIds: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineStatusByMode gets the line status of for all lines for the given modes
*/
func (a *Client) LineStatusByMode(params *LineStatusByModeParams, opts ...ClientOption) (*LineStatusByModeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineStatusByModeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_StatusByMode",
		Method:             "GET",
		PathPattern:        "/Line/Mode/{modes}/Status",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineStatusByModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineStatusByModeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_StatusByMode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineStatusBySeverity gets the line status for all lines with a given severity a list of valid severity codes can be obtained from a call to line meta severity
*/
func (a *Client) LineStatusBySeverity(params *LineStatusBySeverityParams, opts ...ClientOption) (*LineStatusBySeverityOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineStatusBySeverityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_StatusBySeverity",
		Method:             "GET",
		PathPattern:        "/Line/Status/{severity}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineStatusBySeverityReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineStatusBySeverityOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_StatusBySeverity: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineStopPoints gets a list of the stations that serve the given line id
*/
func (a *Client) LineStopPoints(params *LineStopPointsParams, opts ...ClientOption) (*LineStopPointsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineStopPointsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_StopPoints",
		Method:             "GET",
		PathPattern:        "/Line/{id}/StopPoints",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineStopPointsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineStopPointsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_StopPoints: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineTimetable gets the timetable for a specified station on the give line
*/
func (a *Client) LineTimetable(params *LineTimetableParams, opts ...ClientOption) (*LineTimetableOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineTimetableParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_Timetable",
		Method:             "GET",
		PathPattern:        "/Line/{id}/Timetable/{fromStopPointId}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineTimetableReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineTimetableOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_Timetable: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
LineTimetableTo gets the timetable for a specified station on the give line with specified destination
*/
func (a *Client) LineTimetableTo(params *LineTimetableToParams, opts ...ClientOption) (*LineTimetableToOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewLineTimetableToParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Line_TimetableTo",
		Method:             "GET",
		PathPattern:        "/Line/{id}/Timetable/{fromStopPointId}/to/{toStopPointId}",
		ProducesMediaTypes: []string{"application/json", "text/json", "application/xml", "text/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &LineTimetableToReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*LineTimetableToOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for Line_TimetableTo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
